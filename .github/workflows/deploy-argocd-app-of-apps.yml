# This reusable workflow automates the deployment of a Helm chart using the ArgoCD App Of Apps pattern.
# It is designed for environments where applications are managed via ArgoCD and Helm, supporting templated manifests.
#
# Usage:
#
# - Triggered by a `repository_dispatch` event (see: https://docs.github.com/en/actions/reference/events-that-trigger-workflows#repository_dispatch).
# - Intended for CI/CD pipelines that need to deploy or update applications in Kubernetes via ArgoCD.
# - Supports templated Application manifests for flexible deployment scenarios.
#
# References:
#
# - ArgoCD App Of Apps Pattern: https://argo-cd.readthedocs.io/en/stable/operator-manual/cluster-bootstrapping/#app-of-apps-pattern
#
# Dispatch Payload Example:
#
# ```json
# {
#   "event_type": "deploy",
#   "client_payload": {
#     "deployment-id": "unique deployment id (e.g. 1234)",
#     "environment": "target environment (e.g. reviews-app, staging, production)",
#     "repository": "source repository name (e.g. my-repository)",
#     "chart": "Helm chart URI with tag (e.g. ghcr.io/my-org/my-repository/charts/application:0.1.14-pr-82-xxx)",
#     "chart-values": "Array of values to inject in the chart (e.g. [{\"path\":\"application.appUri\",\"value\":\"https://my-app-review-app-1234.my-org.com\"}])",
#     "url": "URL of the deployed application (e.g. https://my-app-review-app-1234.my-org.com)"
#   }
# }
# ```
#
# Key Features:
#
# - Validates and extracts deployment parameters from the dispatch payload.
# - Parses Helm chart URI for chart name, repository, and version.
# - Supports templated manifest files for both Application and extra manifest resources.
# - Updates manifest files with deployment-specific values and chart configuration.
# - Creates and merges a pull request for the deployment manifest changes.
---
name: Deploy ArgoCD App of Apps

on:
  workflow_call:
    inputs:
      runs-on:
        description: |
          JSON array of runner(s) to use.
          See https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job.
        type: string
        default: '["ubuntu-latest"]'
        required: false
      template-filename:
        description: Filename of the template to use.
        required: false
        type: string
        default: "template.yml.tpl"
      github-app-id:
        description: |
          GitHub App ID to generate GitHub token in place of github-token.
          See https://github.com/actions/create-github-app-token.
        required: false
        type: string
    secrets:
      github-token:
        description: |
          GitHub token for creating and merging pull request (permissions contents: write and pull-requests: write, workflows: write).
          See https://github.com/hoverkraft-tech/ci-github-common/blob/main/actions/create-and-merge-pull-request/README.md.
      github-app-key:
        description: |
          GitHub App private key to generate GitHub token in place of github-token.
          See https://github.com/actions/create-github-app-token.
    outputs:
      deployment-id:
        description: "Deployment ID"
        value: ${{ jobs.publish-manifest.outputs.deployment-id }}
      repository:
        description: "Source repository name"
        value: ${{ jobs.publish-manifest.outputs.repository }}
      url:
        description: "Deployment URL"
        value: ${{ jobs.publish-manifest.outputs.url }}

permissions: {}

jobs:
  publish-manifest:
    runs-on: ${{ fromJson(inputs.runs-on) }}
    permissions:
      contents: read
      pull-requests: write
      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      id-token: write
    outputs:
      deployment-id: ${{ steps.check-client-payload.outputs.deployment-id }}
      repository: ${{ steps.check-client-payload.outputs.repository }}
      url: ${{ steps.check-client-payload.outputs.url }}
    steps:
      - id: check-client-payload
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const fs = require("node:fs");
            const path = require("node:path");

            const deploymentId = ${{ toJSON(github.event.client_payload['deployment-id']) }};
            if (!deploymentId) {
              return core.setFailed("Deployment ID is not defined in the client payload");
            }
            core.setOutput("deployment-id", deploymentId);

            let environment = ${{ toJSON(github.event.client_payload.environment) }};
            if (!environment) {
              return core.setFailed("Environment is not defined in the client payload");
            }
            core.setOutput("environment", environment);

            const repository = ${{ toJSON(github.event.client_payload.repository) }};
            if (!repository) {
              return core.setFailed("Repository is not defined in the client payload");
            }
            core.setOutput("repository", repository);

            const url = ${{ toJSON(github.event.client_payload.url) }};
            if (url) {
              core.setOutput("url", url);
            }

            const chart = ${{ toJSON(github.event.client_payload.chart) }};
            if (!chart) {
              return core.setFailed("Chart is not defined in the client payload");
            }
            core.setOutput("chart", chart);

            const chartValues = ${{ toJSON(github.event.client_payload['chart-values']) }};
            if (chartValues) {
              core.setOutput("chart-values", chartValues);
            }

            const initiatedBy = ${{ toJSON(github.event.client_payload['initiated-by']) }};
            if (!initiatedBy) {
              return core.setFailed("Initiated-by is not defined in the client payload");
            }
            core.setOutput("initiated-by", initiatedBy);

      - id: chart-variables
        uses: hoverkraft-tech/ci-github-container/actions/helm/parse-chart-uri@0d92511a38c93e30ae0f8b82346116946987a9ca # 0.30.0
        with:
          uri: ${{ steps.check-client-payload.outputs.chart }}

      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          persist-credentials: false

      # FIXME: This is a workaround for having workflow actions. See https://github.com/orgs/community/discussions/38659
      # jscpd:ignore-start
      - id: oidc
        uses: ChristopherHX/oidc@73eee1ff03fdfce10eda179f617131532209edbd # v3

      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          persist-credentials: false
          path: ./self-workflow
          repository: ${{ steps.oidc.outputs.job_workflow_repo_name_and_owner }}
          ref: ${{ steps.oidc.outputs.job_workflow_repo_ref }}
          sparse-checkout: |
            actions
      - run: |
          if [ -f .gitignore ]; then grep -q "self-workflow" .gitignore || echo "self-workflow" >> .gitignore; else echo "self-workflow" >> .gitignore; fi
          if [ -f .dockerignore ]; then grep -q "self-workflow" .dockerignore || echo "self-workflow" >> .dockerignore; else echo "self-workflow" >> .dockerignore; fi
      # jscpd:ignore-end
      - id: get-namespace
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const namespace = `${{ steps.check-client-payload.outputs.repository }}-${{ steps.check-client-payload.outputs.environment }}`;
            core.setOutput("namespace", namespace);

      - id: slugify-namespace
        uses: hoverkraft-tech/ci-github-common/actions/slugify@a55670b58d3e064526201acde6c720ede638420c # 0.31.0
        with:
          value: ${{ steps.get-namespace.outputs.namespace }}

      - id: get-manifest-files
        uses: ./self-workflow/actions/argocd/get-manifest-files
        with:
          environment: ${{ steps.check-client-payload.outputs.environment }}
          repository: ${{ steps.check-client-payload.outputs.repository }}

      - id: get-manifest-templates
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const fs = require("node:fs");
            const path = require("node:path");

            const templateFilename = ${{ toJSON(inputs.template-filename) }};
            if (!templateFilename) {
              return core.setFailed(`Template filename is not defined`);
            }

            const applicationFile = ${{ toJSON(steps.get-manifest-files.outputs.application-file) }};
            if (!applicationFile) {
              return core.setFailed(`Application file is not defined`);
            }

            const manifestFile = ${{ toJSON(steps.get-manifest-files.outputs.manifest-file) }};
            if (!manifestFile) {
              return core.setFailed(`Manifest file is not defined`);
            }

            const applicationTemplateFile = `${path.dirname(applicationFile)}/${templateFilename}`;
            const isTemplateApplication = fs.existsSync(applicationTemplateFile);
            if (!isTemplateApplication) {
              return;
            }

            await io.cp(applicationTemplateFile, applicationFile, { force: true });

            const manifestTemplateFile = `${path.dirname(manifestFile)}/${templateFilename}`;
            if (!fs.existsSync(manifestTemplateFile)) {
              return core.setFailed(`No template file found in "${manifestTemplateFile}"`);
            }

            await io.cp(manifestTemplateFile, manifestFile, { force: true });

      - uses: ./self-workflow/actions/deploy/argocd-manifest-files
        with:
          deployment-id: ${{ steps.check-client-payload.outputs.deployment-id }}
          application-repository: ${{ steps.check-client-payload.outputs.repository }}
          application-file: ${{ steps.get-manifest-files.outputs.application-file }}
          manifest-file: ${{ steps.get-manifest-files.outputs.manifest-file }}
          namespace: ${{ steps.slugify-namespace.outputs.result }}
          chart-name: ${{ steps.chart-variables.outputs.name }}
          chart-repository: ${{ steps.chart-variables.outputs.repository }}
          chart-version: ${{ steps.chart-variables.outputs.version }}
          chart-values: ${{ steps.check-client-payload.outputs.chart-values }}
          initiated-by: ${{ steps.check-client-payload.outputs.initiated-by }}

      # jscpd:ignore-start
      - uses: actions/create-github-app-token@7e473efe3cb98aa54f8d4bac15400b15fad77d94 # v2.2.0
        if: inputs.github-app-id
        id: generate-token
        with:
          app-id: ${{ inputs.github-app-id }}
          private-key: ${{ secrets.github-app-key }}
      # jscpd:ignore-end

      - uses: hoverkraft-tech/ci-github-common/actions/create-and-merge-pull-request@a55670b58d3e064526201acde6c720ede638420c # 0.31.0
        with:
          github-token: ${{ steps.generate-token.outputs.token || secrets.github-token || github.token }}
          branch: feat/deploy-${{ steps.slugify-namespace.outputs.result }}
          title: "feat(${{ steps.check-client-payload.outputs.repository }}): deploy ${{ steps.chart-variables.outputs.version }} to ${{ steps.check-client-payload.outputs.environment }}"
          body: Deploy ${{ steps.check-client-payload.outputs.repository }} ${{ steps.chart-variables.outputs.version }} to ${{ steps.check-client-payload.outputs.environment }}
          commit-message: |
            feat(${{ steps.check-client-payload.outputs.repository }}): deploy ${{ steps.chart-variables.outputs.version }} to ${{ steps.check-client-payload.outputs.environment }}"

            [skip ci]
