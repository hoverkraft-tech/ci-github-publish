name: "Deployment - Get finished deployment"
description: |
  Waits for a GitHub deployment to reach a terminal state and returns its latest status and metadata.

  This action polls the GitHub Deployment Status API for the
  provided deployment ID until it observes a terminal state (`success`, `failure` or `error`),
  or until the specified timeout (in seconds) elapses.

  It uses exponential backoff between checks to reduce API pressure.
  The action sets outputs with the final deployment state, the environment name and the environment URL (if present).
author: hoverkraft
branding:
  icon: clock
  color: blue

inputs:
  deployment-id:
    description: "The ID of the GitHub deployment to wait for (numeric ID)"
    required: true
  timeout:
    description: "Maximum time to wait for a terminal deployment status, in seconds"
    required: false
    default: "240"
  allow-failure:
    description: |
      If "true", the action will not mark the step as failed when the deployment finishes with a non-success terminal state
      (for example `failure` or `error`).
      When `false` (default), the step fails if the final deployment status is not `success`.
    required: false
    default: "false"

outputs:
  status:
    description: "The final terminal state of the deployment (e.g. `success`, `failure`, `error`)"
    value: ${{ steps.get-deployment-status.outputs.status }}
  url:
    description: "The environment URL associated with the deployment (if provided by the status)"
    value: ${{ steps.get-deployment-status.outputs.url }}
  environment:
    description: "The target environment name for the deployment (e.g. `production`, `staging`)"
    value: ${{ steps.get-deployment-status.outputs.environment }}

runs:
  using: "composite"
  steps:
    - id: get-deployment-status
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
      with:
        script: |
          const deploymentId = `${{ inputs.deployment-id }}`;
          const finishedStatuses = ["success", "failure", "error"];

          const timeout = parseInt(`${{ inputs.timeout }}`, 10);
          if (isNaN(timeout) || timeout <= 0) {
            core.setFailed(`Invalid timeout value: ${timeout}`);
            return;
          }

          async function isDeploymentFinished(deploymentId) {
            const deploymentStatuses = await github.paginate(
              github.rest.repos.listDeploymentStatuses.endpoint.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deploymentId,
              })
            );

            // Order by updated_at descending
            deploymentStatuses.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
            if (deploymentStatuses.length === 0) {
              return null;
            }

            const deploymentStatus = deploymentStatuses[0];

            const state = deploymentStatus.state;
            core.info(`Deployment status state: ${state}`);

            if (finishedStatuses.includes(state)) {
              return deploymentStatus;
            }

            return null;
          }

          async function waitForDeployment(deploymentId, timeout) {
              const startTime = Date.now();
              let delay = 1000; // Start with 1 second interval

              while (Date.now() - startTime < timeout * 1000) {
                  const deploymentStatus = await isDeploymentFinished(deploymentId);
                  if (deploymentStatus !== null) {
                      return deploymentStatus;
                  }

                  core.info(`Waiting for deployment... Next check in ${delay / 1000} seconds`);
                  await new Promise(resolve => setTimeout(resolve, delay));

                  delay = Math.min(delay * 2, timeout * 1000); // Exponential backoff up to timeout max
              }
              return null;
          }

          const deploymentStatus = await waitForDeployment(deploymentId, timeout);

          if (!deploymentStatus) {
            core.setFailed(`Deployment ${deploymentId} did not finish within ${timeout} seconds.`);
            return;
          }

          core.setOutput("url", deploymentStatus.environment_url);
          core.setOutput("status", deploymentStatus.state);
          core.setOutput("environment", deploymentStatus.environment);

          const allowFailure = `${{ inputs.allow-failure }}`.toLowerCase() === "true";
          if (!allowFailure && deploymentStatus.state !== "success") {
            core.setFailed(`Deployment ${deploymentId} failed with status: ${deploymentStatus.state}`);
          }

          core.info(`Deployment ${deploymentId} finished with status: ${deploymentStatus.state}`);
